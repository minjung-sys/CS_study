# 메모리
# 메모리 계층

---

:메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어 있다

- 레지스터 : CPU 안에 있는 작은 메모리, 휘발성, 속도가 가장 빠르고 기억 용량이 가장 적다
- 캐시 : 휘발성, 속도가 빠르고 기억용량이 적다
- 주기억장치 : RAM을 가리킴. 휘발성, 메모리 속도와 기억 용량이 보통
- 보조기억장치: HDD, SDD를 말하여 휘발성, 속도 낮음 , 기억용량이 많다

---

## 캐시(Cache)

**캐시**는 데이터를 미리 복사해 놓는 `임시 저장소이`자 빠른 장치와 느린 장치에서 속도 차이에 따른 `병목 현상을 줄이기 위한 메모리`→ 캐시를 통해 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 계산 시간을 절약할 수 있음

실제로 메모리와 CPU 사이의 속도 차이가 크기 때문에 중간에 레지스터 계층을 둬서 속도 차이를 해결한다.
속도 차이를 해결하기 위해 계층과 계층 사이에 있는 계층을 `캐싱 계층`이라 함 

**지역성의 원리**

캐시를 직접 설정할때 지역성을 고려하여 자주 사용하는 데이터를 기반으로 설정해야 함 

→ **시간 지역성(temporal locality)** 와 **공간 지역성(spatial locality)** 로 나뉨

`시간지역성`

: 최근 사용한 데이터에 다시 접근하려는 특성 

`공간지역성`

: 최근 접근한 데이터를 이루고 있는 공간이나 , 그 가까운 공간에 접근하는 특성 

---

## 캐시히트와 캐시미스

`캐시히트` → 캐시에서 원하는 데이터를 찾음 
 :: 위치도 가깝고 CPU 내부 버스를 기반으로 작동하기 때문에 빠르다

`캐시미스` → 데이터를 주메모리로 가서 찾아옴
 :: 시스템 버스를 기반으로 작동하기 때문에 느리다 


`캐시매핑`
캐시가 히트되기 위해 매핑하는 방법 , CPU의 레지스터와 주 메모리간에 데이터를 주고받을 때를 기반으로 설명
레지스터는 주 메모리에 비해 작고, 주 메모리는 굉장히 크기 때문에 작은 레지스터가 캐시 계층으로써 역할을 하려면 매핑을 어떻게 하느냐가 중요하다

- **직접 매핑** : 처리가 빠르지만 충돌 발생이 많다

- **연관 매핑** : 관련 있는 캐시와 메모리를 매핑, 충돌이 적지만 모든 블록을 탐색하기 때문에 속도가 느리다

- **집합 연관 매핑** : 직접 매핑과 연관 매핑을 합친 것. 순서는 일치시키지만 집합을 둬서 저장하며 블록화되어 있어 검색은 효율적이다

**웹 브라우저의 캐시**

대표적인 캐시로 **저장소 쿠키, 로컬 스토리지 , 세션 스토리지가 존재**

*사용자의 커스텀 정보나 인증 모듈 관련 사항들을 브라우저에 저장해서 서버에 요청할때 아이덴티티나 중복 요청 방지를 위해 사용된다*

`쿠키`
: **만료 기한이 있는 키 값 저장소** 4KB까지 데이터를 저장할 수 있으며 만료 기한을 정할 수 있다. **보통 서버에서 만료 기한을 정한다**

`로컬 스토리지`
: **만료 기한이 없는 키 값 저장소**, 10MB까지 저장할 수 있으며 **웹 브라우저를 닫아도 유지되고 도메인 단위로 저장, 생성된다**. 클라이언트에서만 수정이 가능

`세션 스토리지`
: **만료 기한이 없는 키 값 저장소**, 탭 단위로 세션 스토리지를 생성하며 **탭을 닫을 때 해당 데이터가 삭제, 5MB까지 저장이 가능**하며 클라이언트에서만 수정이 가능

**데이터 베이스의 캐싱 계층**

데이터 베이스 시스템을 구축할 때도 메인 데이터베이스 위에 레디스 데이터 베이스 계층을 **캐싱 계층**으로 둬서 성능을 향상시키기도 한다

---

# 메모리 관리

## 가상 메모리

가상 메모리는 메모리 관리 기법의 하나로 컴퓨터가 **실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것**

> 이때 , 가상적으로 주어진 주소를 가상 주소 (logical address)라고 하며 , 실제 메모리 상에 있는 주소를 실제 주소 (physical address)라고 한다.
> 

가상 메모리는 **가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어있는 페이지 테이블로 관리**된다. 이때 속도향상을 위해 TLB를 사용한다

`스와핑`
가상 메모리는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우 , 페이지 폴트가 발생
이를 방지하기 위해 RAM을 효과적으로 운영하는 것을 스와핑(swapping)이라고 한다

`페이지 폴트`
프로세스 주소 공간에는 존재하지만 지금 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우 발생 

`스레싱`
메모리의 페이지 폴트율이 높은 것을 의미, 컴퓨터의 성능 저하를 초래함

→ 해결 방법으로 메모리를 늘리거나, ,HDD를 사용한다면 HDD를 SDD로 바꾸는 방법 존재, 이 외에 운영체제에서 해결할 수 있는 방법으로 작업세트와 PEF존재

- **작업세트**
    
    프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어 미리 메모리에 로드
    
- PFF
    
    페이지 폴트 빈도를 조절하는 방법, 상한선과 하한선을 만들어 조절
    

---

### 메모리 할당

***연속 할당**과 **불연속 할당**으로 나뉨*

**연속 할당**

: 메모리에 연속적으로 공간을 할당하는 것

`고정 분할 방식`

- 메모리를 미리 나누어 관리하는 방식, 메모리가 미리 나뉘어 있기 때문에 융통성이 없고 내부 단편화 발생

`가변 분할 방식`

- 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠서 사용
- 외부 단편화는 발생할 수 있음
- **최초적합, 최적적합, 최악적합이 존재**

**불연속 할당**

: 메모리를 연속적으로 할당하지 않는 것 

`페이징`

- 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스 할당
- **홀 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해진다**

`세그멘테이션`

- 의미 단위인 세그먼트로 나누는 방식
- **공유와 보안 측면에서 좋으며 홀 크기가 균일하지 않은 문제 발생**

`페이지드 세그멘테이션`

- 공유나 보안을 의미 단위의 세그먼트로 나누고, 물리적 메모리는 페이지로 나누는 것

---

### 페이지 교체 알고리즘

**오프라인 알고리즘** 

: 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘, 가장 좋은 방법이다.

**FIFO**

: 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법

**LRU**

:참조가 가장 오래된 페이지를 교체, 오래된 페이지를 파악하기 위해 각 페이지마다 계수기 , 스택을 두어야 함

`NUR`

: LRU에서 발전한 알고리즘 이다. 

일명 clock 알고리즘 이라고 하며 0과 1을 가진 비트를 두어 1은 최근에 참조된 , 0은 참조되지 않음을 의미한다
시계 방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 프로세스를 교체하고 해당 부분을 1로 바꾸는 알고리즘 

**LFU**

:가장 참조 횟수가 적은 페이지를 교체, 즉 많이 사용되지 않은 것을 교체하는 방법